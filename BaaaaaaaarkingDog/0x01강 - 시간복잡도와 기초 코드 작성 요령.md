# 0x01강 - 시간복잡도와 기초 코드 작성 요령



## 0x00 시간, 공간복잡도

| N의 크기      | 허용 시간복잡도 |
| ------------- | --------------- |
| N <= 11       | O(N!)           |
| N <= 20       | O(2^N)          |
| N <= 100      | O(N^4)          |
| N <= 500      | O(N^3)          |
| N <= 3000     | O(N^2 * lgN)    |
| N <= 5000     | O(N^2)          |
| N <= 1000000  | O(NlgN)         |
| N <= 10000000 | O(N)            |
| 그 이상       | O(lgN), O(1)    |



## 0x01 표준 입출력

### cin/cout 시간초과 방지 명령어

```c++
int main(void) {
    ios::sync_with_stdio(0); // c++ stream과 c stream 사이의 sync 끄기(cout만 사용해야 함. no printf)
    cin.tie(0); // cin과 cout이 번갈아 나올 때마다 flush하지 않도록 하는 명령 -> 줄바꿈은 \n으로 써야함. no endl
}
```



## 0x02 기초 지식

### 정수 자료형의 범위

- char 자료형은 1byte
  - unsigned char에서는 최상위 비트가 2^7이지만
  - char에서는 최상위 비트가 2^7이 아닌 -2^7을 의미. 연산을 편하게 처리하기 위함.
- short - 2byte, int - 4byte, long long - 8byte
  - 정수를 표현하기 위해 보통 int, long long 자료형 사용
  - int가 long long에 비해 속도, 성능 모두 우수하나
  - 80번째 피보나치 수를 구하는 문제와 같이 int 표현 범위를 넘어서는 수를 저장해야 하면 반드시 long long 자료형 사용해야.



### Integer overflow



### 실수 자료형

- float - 4byte, double - 8byte
- 과학적 표기법(부동소수점)
- float의 32bit는 sign(1bit)/exponent(8bit)/fraction field(23bit)로 구분됨
- double의 64bit는 sign(1bit)/exponent(11bit)/fraction field(52bit)로 구분됨
- -6.75 = -1.1011(2) * 2^2를 float에 저장하는 예
  - 1	10000001	000...0011011
  - 음수이기 때문에 sign은 1
  - exponent field에는 음의 지수승까지 원만하게 표현하기 위해 원래 지수승인 2에 127을 더한 129를 8bit 공간에 2진수로 적고, fraction field에는 11011을 적음. 지수승에 더해지는 127을 bias라 부르고, bias 덕분에 지수 부분에 2^(-127)부터 2^127까지 표현할 수 있음
  - double에 저장할 때에도 마찬가지 방법이나, exponent field가 11bit이므로 bias가 1023
- 이해가 잘 가지 않는다면 IEEE 754 format으로 검색해서 찾아보면 됨
- 알고리즘 문제를 풀 때 메모리 문제로 인해 double을 쓰면 안 되는 경우는 발견하지 못함. 따라서 모든 실수 관련 문제에 double을 쓰면 됨.

1. 실수의 저장/연산 과정에서 반드시 오차가 발생할 수밖에 없다.
   - float은 2^(-23) = 1.19 * 10^(-7), double은 2^(-52) = 2.22 * 10^(-16)까지 정확하게 표현할 수 있기 때문에 float은 대략 상대 오차 10^(-6)까지 안전하고 double은 10^(-15)까지 안전
   - 문제에서 오차를 허용한다고 주어지는 경우에는 실수를 써도 되지만 그렇지 않다면 모든 연산을 정수에서 해결할 수 있도록 해야 실수로 인한 오답을 방지할 수 있음.
2. double에 long long 범위의 정수를 함부로 담으면 안된다.
   - double은 상대오차 10^(-15) 정도까지만 안전. int 범위의 정수는 10^(-15)보다 작으므로 괜찮지만 double에 long long 범위의 정수(예를 들어 10^18 + 1)을 담을 경우 오차가 섞인 값이 저장됨.
3. 실수를 비교할 때는 등호를 사용하면 안 된다.
   - 두 수의 차이가 대략 10^(-12) 아래라면 동일하다고 처리를 하는 것이 안전.
4. 그 외(지엽적인 부분)
   - 실수의 뺄셈은 상대오차가 보장되지 않는다.
   - 여러 개의 수를 더할 때 작은 수끼리 먼저 더하고 이후 큰 수를 더해야 한다.
   - zlzmsrhak님이 작성하신 글(https://www.acmicpc.net/blog/view/37) 참고



### 전역 변수와 지역 변수

지역 변수는 0으로 초기화되지 않지만 전역 변수는 0으로 초기화됨



### 채점 결과

런타임 에러 : 프로그램이 정상적으로 실행되어 동작하던 도중 비정상적으로 종료되었습니다. main 함수가 0이 아닌 다른 값을 반환하는 경우, 0으로 나눈 경우, 배열에서 잘못된 인덱스 값에 접근한 경우 등의 다양한 이유로 발생할 수 있는 에러

컴바일 에러 : 컴파일에 실패했습니다. 클릭하면 컴파일 에러 메시지를 볼 수 있음.





## 0x03 코드 작성 요령

헤더는 `bits/std++.h`를 사용하자. 해당 헤더 안에 모든 표준 라이브러리가 포함되어 있음. 단, MSVC에는 해당 헤더가 존재하지 않음. 직접 경로에 헤더파일을 추가해주면 MSVC에서도 `bits/stdc++.h` 하나로 깔끔하게 여러 라이브러리를 가져다 쓸 수 있음.

```c++
#include <bits/stdc++.h>
using namespace std;
int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);
}
```

문제를 풀고난 뒤 다른 사람의 코드를 보며 다른 사람은 어떻게 접근했는지 이해해보고 좋은 코딩 스킬들을 습득하는 것도 좋은 습관.































