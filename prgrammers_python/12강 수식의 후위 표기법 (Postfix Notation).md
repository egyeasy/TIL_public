# 12강: 수식의 후위 표기법 (Postfix Notation)

이번 강의와 다음 강의에서는, 지난 강의 (제 11 강) 에서 마련한 스택을 이용하여 문제를 풀어내는 예제를 소개합니다. 이 예제는 4칙연산 (더하기 `+`, 빼기 `-`, 곱하기 `*`, 나누기 `/`) 과 괄호로 이루어진 수식이 주어졌을 때 연산의 우선순위를 지키면서 이 수식의 값을 계산하는 알고리즘입니다. 그러기 위해서 수식의 후위 표기법 (postfix notation) 이라는 것을 이용합니다.

우리가 일상에서 사용하는 수식의 표기법은, 중위 표기법 (infix notation) 이라고 부를 수 있습니다. 두 개의 피연산자 `A` 와 `B` 를 가지고 덧셈을 하는 수식을 표기하면 `A + B` 와 같이 되는데, 이 때 연산자인 `+` 가 두 피연산자의 사이에 (가운데에) 위치하기 때문에 중위 표기법이라고 부릅니다. 그렇다면 후위 표기법이란 무엇일까요? 연산자를 두 피연산자의 뒤에 쓰는 방식입니다. 따라서 앞의 예인 `A + B` 를 후위 표기법으로 표기하면 `AB+` 가 됩니다.

후위 표기법을 이용하면, 괄호를 쓰지 않고도 연산의 우선순위를 수식에 표현할 수 있습니다. 예를 들어, 중위 표기법으로 표기된 `(A + B) * (C + D)` 를 후위 표기법으로 변환하여 쓰면

```
A B + C D + *
```

와 같이 표현됩니다. `A` 와 `B` 를 가장 먼저 덧셈하고, `C` 와 `D` 또한 덧셈한 뒤, 마지막으로 그 두 결과를 곱한다는 뜻입니다. 그렇다면, `A + B * C` 를 후위 표기법으로 변환하면 어떻게 될까요?

```
A B C * +
```

가 됩니다. (`A`) 와, (`B` 와 `C` 의 곱) 을 더한다는 의미가 됩니다.

이렇게 수식을 후위 표기법으로 표기하면, 컴퓨터가 (프로그램이) 수식을 계산하는 데 유리 (편안) 해집니다. 왼쪽부터 수식을 읽으면서 연산자를 만날 때마다 두 피연산자에 그 셈을 적용하면 되기 때문인데요, 이 때 스택이 이용됩니다.

이 강의에서는 문자열로 주어진 중위 표기법 수식을 후위 표기법 수식으로 변환하는 알고리즘을 소개합니다. 이 때에도 스택이 이용됩니다. 다시 말하면, (1) 중위 표기법으로 쓰인 수식을 후위 표기법으로 변환하고, (2) 후위 표기법으로 쓰인 수식을 계산하는 두 단계를 거치게 되는데, 그 두 단계에서 각각 스택을 활용합니다.

이번 강의에서는 위 (1) 을 행하는 알고리즘을 설계하고, 스택을 어떻게 활용하는지를 설명합니다. 실제로 주어진 수식을 후위 표기법으로 변환하는 코드는 연습문제를 통하여 직접 작성해보세요.



### 괄호의 처리

- 여는 괄호는 스택에 push
- 닫는 괄호를 만나면 여는 괄호가 나올 때까지 pop
- 연산자를 만났을 때, 여는 괄호 너머까지 pop 하지 않도록 여는 괄호의 우선순위는 가장 낮게 설정



### 알고리즘의 설계

- 중위 표현식을 왼쪽부터 한 글자씩 읽어서
  - 피연산자이면 그냥 출력
  - `(`이면 스택에 push
  - `)` 이면 `(`  이 나올 때까지 스택에서 pop, 출력
  - 연산자이면 스택에서 이보다 높(거나 같)은 우선순위 것들을 pop, 출력. 그리고 이 연산자는 스택에 push
  - 스택에 남아있는 연산자는 모두 pop, 출력

### 코드 구현 힌트

- 스택의 맨 위에 있는 연산자와 우선순위 비교 -> 스택의 peek() 연산 이용
- 스택에 남아 있는 연산자 모두 pop()하는 순환문 -> `While not opStack.isEmpty()`





# 12강 실습: 중위표현 수식 -> 후위표현 수식

중위 표기법을 따르는 수식 S 가 인자로 주어질 때, 이 수식을 후위 표기법을 따르는 수식으로 변환하여 반환하는 함수 solution() 을 완성하세요.

인자로 주어지는 수식 문자열 S 는 영문 대문자 알파벳 한 글자로 이루어지는 변수 `A - Z` 까지와 4칙연산을 나타내는 연산자 기호 `+, -, *, /`, 그리고 여는 괄호와 닫는 괄호 `(, )` 로 이루어져 있으며 공백 문자는 포함하지 않는 것으로 가정합니다. 또한, 올바르게 구성되지 않은 수식은 인자로 주어지지 않는다고 가정합니다. (수식의 유효성은 검증할 필요가 없습니다.)

문제에서 미리 주어진, 연산자의 우선순위를 표현한 python `dict` 인 `prec` 을 활용할 수 있습니다.

또한, 스택의 기초 강의에서 이미 구현한, 배열을 이용한 스택의 추상적 자료 구조 코드가 이미 포함되어 있으므로 그대로 이용할 수 있습니다.



```python
class ArrayStack:

    def __init__(self):
        self.data = []

    def size(self):
        return len(self.data)

    def isEmpty(self):
        return self.size() == 0

    def push(self, item):
        self.data.append(item)

    def pop(self):
        return self.data.pop()

    def peek(self):
        return self.data[-1]

prec = {
    '*': 3, '/': 3,
    '+': 2, '-': 2,
    '(': 1
}

def solution(S):
    opStack = ArrayStack()
    answer = ''
    for i in S:
        if i in prec:
            if opStack.isEmpty():
                opStack.push(i)
            else:
                if i == '(':
                    opStack.push(i)
                elif prec[opStack.peek()] >= prec[i]:
                    answer += opStack.pop()
                    opStack.push(i)
                else:
                    opStack.push(i)
        elif i == ')':
            while not opStack.peek() == '(':
                answer += opStack.pop()
            opStack.pop()
        else:
            answer += i
    while not opStack.isEmpty():
        answer += opStack.pop()
    return answer
```

