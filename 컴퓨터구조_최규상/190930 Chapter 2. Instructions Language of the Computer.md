# 190930 Chapter 2. Instructions: Language of the Computer

## 2.1 Introduction

### Instruction Set

- 컴퓨터의 인스터럭션 레퍼토리
- 초창기 컴퓨터들은 인스트럭션이 단순했다.



### Instruction Set Architecture(ISA)

- the abstract interface between the h/w and the lowest level s/w
- 머신 랭귀지 프로그램에 register, memory access, I/O에 대한 정보를 담아서 실행할 수 있게 주는 것.
- 같은 소프트웨어를 여러 개의 CPU에서 실행할 수 있게 함



### Application Binary Interface(ABI)

- ISA + OS interface
- ABI만 같다면 같은 프로그램은 어디에서나 실행될 수 있다.
- 같은 CPU를 사용한다는 것은 같은 instruction set을 쓴다는 것. 같은 Windows를 쓴다 -> 같은 OS interface를 쓴다.



### The MIPS Instruction Set

- MIPS는 CPU의 이름
- MIPS에서 사용하는 IS를 알아보자





## 2.2 Operations of Hardware

### Arithmetic Operations

#### 더하기

```python
 add a, b, c # a gets b + c
```



**Design Principle 1**

간단하게 만들어야 가격 대비 성능을 좋게 만들 수 있다.



#### C code:

```c
f = (g + h) - (i + j);
```

#### Compiled MIPS code:

```MIPS
add t0, g, h # temp t0 = g + h
add t1, i, j # temp t1 = i + j
# 결과	
```



### Register Operands

- Arithmetic instructions use register operands
- MIPS has a 32
- 한 개의 word 는 32bit data
- Assembler names
  - temporary values
  - saved variables



**Design Principle 2: Smaller is faster**

c.f. main memory: millions of locations -> 이거에 비해 작기 때문에 1000배 정도 빨라진다.



#### C code:

f = (g + h) - (i + j);

- j, ..., j in $s0, ... , $s4



#### Compiled MIPS code:

add $t0, $s0, $s1

...



### Byte Addresses -> 아주 중요

- 대부분의 컴퓨터에서는 메모리를 byte 단위로 엑세스한다. 
  - Alignment restriction - 메모리 어드레스는 word 단위로 align된다. word 단위로 access하게 됨.
- Endian - 데이터를 워드에 어떤 방식으로 저장할 것인가
  - Big Endian: leftmost byte is word address. IBM 360/370, MIPS. 숫자의 큰 값을 끝에 놓는다.
  - LIttle Endian: rightmost byte is word address. Intel 80x86. 숫자의 작은 값을 끝에 놓는다.



### Memory Operands

- Main memory에는 데이터를 저장한다.
- arithmetic operations를 적용하려면
  - 값을 memory에서 register로 로드해야
  - register에서 결과를 memory로 store 해야.
- Memory is byte addressed
- words are aligned in memory



### ex1

#### C code:

g = h + A[8];



#### Complied MIPS code:

- Index 8 requires offset of 32

```MIPS
lw $t0, 32($s3)  # load word
add $s1, $s2, $t0 # 각 레지스터에 변수를 할당
```

s3에서 32만큼 offset을 두고 들어가서 값을 읽어서 t0에 넣는다.



### Registers vs. Memory

- 레지스터는 메모리보다 엑세스가 빠르다.
- MIPS는 Load-Store Architecture다. - memory에서 로드를 통해 레지스터로 데이터를 옮기고, 이걸 연산해서 store함.
- 컴파일러는 load-strore 과정 때문에 더 많은 명령어가 필요하게 됨.



### MIPS Register File

레지스터는 code의 density가 높아짐.



### Immediate Operands

addi $s3, $s3, 4

-> $s3 = $s3 + 4



- 음수 덧셈은 지원하지 않음



**Design Principle 3: Make the common case fast**

- 작은 상수는 흔하다
- Immediate Operands는 이런 상수들을 바로 쓸 수 있게 함



### The Constant Zero

- Useful for common operands

  add $t0, $s1, 0 -> 값을 그대로 할당하는 데 쓰일 수 있다.





## 2.4 Signed and Unsigned Numbers

### Unsigned Binary Integers

컴퓨터에서는 어떤 내용을 0과 1로 표현한다.



### 2s-Complement Signed Integers

컴퓨터에서는 2의 보수 방식을 사용한다.



x = -x(n-1)*2^(n-1) + x(n-2)*2^(n-2) + ...



0: 0000 ... 0000

1: 1111 ... 1111



### Signed Negation

부호를 바꿔주는 작업

- Complement and add 1

  complement : 1->0, 0->1

- +2 = 0010

- -2 = 1111 1111 .... 1101 + 1 = 1111 1111 ... 1110



### Sign Extension

비트의 수를 확장하더라도 sign은 그대로 유지되어야 함

- In MIPS instruction set

  - addi: extend immediate value
  - lb, lh: extend loaded byte/halfword
  - beq, bne: displacement

- +2: 0000 0010 -> 0000 0000 0000 0010

  -2: 1111 1110 -> 1111 1111 1111 1110





## 2.5 Representing Instructions in the Computer

### Representing Instructions

모든 명령어는 binary(machine code)로 표현됨



- MIPS 명령어
  - 32비트로 표현 됨
  - Small number of formats encoding operation code -> 속도가 빠르다.
  - !Regularity



- Register numbers



### MIPS R-format Instructions

op, rs, rt, rd, shamt, funct



### Hexadecimal

Base 16 - Compact representation of bit strings

Ox라고 접두어를 써서 표현



### MIPS I-format Instructions

op, rs, rt, constant or address

- Immediate arithmetic and load/store instructions
  - rt : destination or source register number



**Design Principle 4: Good design ddemands good compromises**

상이한 두 개를 하나로 잘 만든다 - arithmetic과 load/store를 하나의 방식으로 처리.



### Stored Program Computers

- Binary compatibility : 프로그램이 다른 컴퓨터에서 실행될 수 있는가



## 2.6 Logical Operations

논리 연산. 



### Shift Operations

op, rs, rt, rd, shamt, funct

- shamt: shift 연산을 몇번할지
- Shift left logical
  - 왼쪽으로 쉬프트하고 0으로 채우기
  - sll by i bits multiplies by 2^i
- Shift right logical
  - 오른쪽으로 밀고 0으로 채우기
  - srl by i bits divides by 2^i(**unsigned only**)



### AND operations

- Useful to mask bits in a word

둘 다 1인 것만 고름



### OR Operations

- Useful to include bits in a word



### NOT Operations

- Useful to invert bits in a word
- MIPS has NOR 3-operand instruction

```MIPS
nor $t0, $t1, $zero
```

$zero = 0



## 2.7 Instructions for Making Decisions

### Conditional Operations

- Branch to a labeled instructions if a condition is true
  - Otherwise
- bet rs, rt, L1
  - rs와 rt가 같으면 L1을 실행
- bne rs, rt, L1
  - rs와 rt가 같지 않으면 L1을 실행



#### C code:

```C
if (i==j) f = g + h;
else f = g - h;
```



#### MIPS code:

```MIPS
bne $s3, $s4, Else
add $s0, $s1, $s2
j Exit  # 무조건 Exit으로 간다(jump)
Else: sub $s0, $s1, $s2
Exit: ...
```





### Basic Blocks

- a sequence of instructions with
  - embedded branch가 없어야
  - branch target이 없어야

- 컴파일러는 Basic Block을 찾아서 빨리 실행하도록 되어있음. -> 컴파일러와 프로세서는 이걸 빨리 찾아서 실행하도록 되어있다.



### More Conditional Operations

- Set result to 1 if a condition is true

- slt rd, rs, rt



### Branch Instruction Design

- Why not blt, bge, etc?
- Hardware for <, >=, ... slower than =, !=
  - 같나 틀리나는 빼보면 쉽게 알 수 있음
  - 부등호 연산은 더 느린 clock period를 쓰게 됨 -> 모든 연산이 느려진다.
- beq and bne are the common case



### Signed vs. Unsigned

- Signed comparison: slt, slti
- Unsigned comparison: sltu, sltui































