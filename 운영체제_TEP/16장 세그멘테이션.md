# 16. 세그멘테이션

앞에서는 프로세스 주소 공간 전체를 메모리에 탑재하는 것을 가정해왔다

-> 스택과 힙 사이에 사용되지 않는 큰 공간이 존재. 내부 단편화 발생

-> 메모리 낭비가 심하다

**핵심 질문: 대용량 주소 공간을 어떻게 지원하는가**



## 16.1 세그멘테이션 : 베이스 / 바운드(base/bound)의 일반화

**세그멘테이션** - 주소 공간의 논리적인 단위이자 특정 길이를 가지는 연속적인 주소 공간인 세그먼트(segment)로 주소 공간을 구분하는 것. 세그먼트에는 코드, 스택, 힙이 있을 수 있다.

-> 세그먼트마다 1쌍의 베이스와 바운드 레지스터가 필요하다.

cf. segment fault는 세그먼트 사용 시스템에서 불법적인 주소 접근 시 발생한다.



## 16.2 세그먼트 종류의 파악

하드웨어는 주소 변환을 위해 **세그먼트 레지스터**를 사용한다.

그럼 다음과 같은 사실을 어떻게 알 수 있을까?

1. 가상 주소가 어느 세그먼트를 참조하는지
2. 세그먼트 안에서의 오프셋은 얼마인지



-- | -------------------

세그먼트	오프셋



최상위 2비트를 세그먼트를 가리키는 데 쓴다.

나머지는 해당 세그먼트 내에서의 오프셋이다.



## 16.3 스택

스택의 경우 다른 세그먼트들과는 반대 방향으로 확장된다.

-> 가상 주소 또한 다른 방식으로 변환한다.

이를 위해 세그먼트 레지스터에 해당 세그먼트가 '순방향으로 증가하는지' 여부 또한 저장해야 한다.



## 16.4 공유 지원

메모리 절약을 위해 주소 공간들 간에 특정 메모리 세그먼트를 공유하는 것도 가능하다.

이를 위해 하드웨어에 **protection bit**를 추가해야 한다.

-> 해당 세그먼트에 read/write/execute(코드 실행)가 가능한지 표시하는 정보

프로세스가 불가능한 접근을 시도 -> 하드웨어는 예외 발생 -> 운영체제가 위반 프로세스 처리



## 16.5 소단위 대 대단위 세그멘테이션

지금까지는 소수의 세그먼트(코드, 스택, 힙)만 논의했다. 이것을 **대단위(coarse-grained) 세그멘테이션**이라고 한다.

이와는 반대로 주소 공간을 작은 크기의 공간으로 잘게 나누는 것을 소단위(fine-grained) 세그멘테이션이라고 한다.

-> 소단위에서는 여러 세그멘트의 정보를 메모리에 저장할 수 있는 세그먼트 테이블 같은 하드웨어가 필요하다.

초창기 시스템에서는 소단위 세그멘테이션을 사용하는 경우들이 있었다.



## 16.6 운영체제의 지원

세그멘테이션 방식에서는 물리 메모리 절약이 가능하다.

하지만 이를 위해 운영체제 문제를 해결해야 한다.

1. 문맥 교환시 세그멘트 레지스터의 저장/복원

2. 미사용 중인 물리 메모리 공간의 관리

   각 세그먼트마다 크기가 다를 수 있다 -> 작은 크기의 여러 공간들로 물리 메모리가 채워지면 큰 크기의 공간을 할당할 수 없게 됨(**외부 단편화(external fragmentation**)

   -> 방법 1) **압축** - 기존의 세그멘트를 정리. 한 곳으로 모으기. 비용이 많이 듦

   -> 방법 2) 빈 공간 리스트를 관리하는 알고리즘 사용  -> best-fit, worst-fit, first-fit, buddy algorithm 등



## 16.7 요약

### 장점

세그멘테이션은 메모리 가상화를 효과적으로 실현시킨다.

동적 재배치 + 논리 세그멘트 사이의 공간 낭비를 피함 -> sparse address space를 지원 가능함(대응 가능함)

필요한 산술연산이 쉽고 하드웨어 구현에 적합 -> 속도 빠르고 변환 오버헤드도 최소. + 코드 공유의 장점



### 한계

1. 세그먼트 크기가 일정하지 않음 -> 외부 단편화 발생. 모든 메모리 할당 요청을 충족시키는 것이 어려울 수 있다.
2. 세그멘테이션이 sparse address space를 지원할 만큼 충분히 유연하지는 않다. 잘 사용되지 않는 힙이 세그멘트에 배정되어있다고 할 때 힙에 접근하기 위해서는 힙 전체가 물리 메모리 상에 존재해야 함. -> 다음에 이 해결책을 알아볼 것

 