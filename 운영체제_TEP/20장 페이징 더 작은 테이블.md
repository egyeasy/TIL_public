# 20. 페이징: 더 작은 테이블

선형 페이지 테이블은 상당히 커질 수 있다.



**핵심 질문: 페이지 테이블을 어떻게 더 작게 만들까**



## 20.1 간단한 해법: 더 큰 페이지

페이지 크기를 증가시키면 페이지 테이블의 크기가 간단하게 줄어든다.

하지만  이로 인해 페이지 내부의 낭비 공간이 증가한다 -> **내부 단편화**



## 20.2 하이브리드 접근 방법: 페이징과 세그멘트

페이지 테이블 하나에 코드 페이지, 힙 페이지, 스택 페이지가 할당되어 있다면 나머지 빈 공간을 둔 채로 모든 페이지 테이블 공간이 사용되게 된다.

-> 대안으로, 논리 세그멘트마다 따로 페이지 테이블을 두도록 한다.

베이스 레지스터 : 페이지 테이블의 시작 주소를 갖는다.

바운드 레지스터 : 페이지 테이블의 끝을 나타내기 위해 사용된다.



### 페이지 테이블 항목(PTE)의 주소를 얻는 방법

```c
SN = (VirutalAddress & SEG_MASK) >> SN_SHIFT
VPN = (VirtualAddress & VPN_MASK) >> VPN_SHIFT
AddressOfPTE = Base[SN] + (VPN * sizeof(PTE))
```



### 문제점

1. 여전히 세그멘테이션을 사용해야 한다 -> 원하는 만큼은 유연하지 못하다.

   sparsely used 힙의 경우에는 페이지 테이블의 낭비가 발생할 수 있다.

2. 다양한 페이지 테이블 크기가 가능 -> **외부 단편화**가 유발된다



## 20.3 멀티 레벨 페이지 테이블

선형 페이지 테이블을 트리 구조로 표현

### 기본 개념

1. 페이지 테이블을 페이지 크기의 단위로 나눈다.
2. 페이지 테이블의 페이지가 유효하지 않은 항목만 있다면 해당 페이지를 할당하지 않는다.
3. **page directory**라는 자료구조를 사용하여 페이지 테이블 각 페이지의 할당 여부와 위치를 파악한다.



page directory의 항목을 페이지 디렉터리 항목(PDE)라고 한다.

PDE는 유효 비트와 페이지 프레임 번호(PFN)로 이루어져있다.

유효 비트 - 그 항목이 가리키고 있는 페이지들 중 최소한 하나가 유효한지를 표시



### 유의 사항

1. TLB 미스 시 주소 변환을 위해 두 번의 메모리 로드가 발생(페이지 디렉터리와 PTE 접근을 위해 한번 씩)

-> **시간과 공간의 상호 절충**. 페이지 테이블 크기를 줄이는 데 성공하였으나, 메모리 접근 시간이 증가한 것.

2. 복잡도 증가



### 멀티 레벨 페이징 예제

페이지 테이블은 16개의 페이지, 256개의 항목으로 나뉘어져있다.

페이지 디렉토리는 페이지 테이블의 페이지마다 하나씩 있어야 하므로 16개의 항목이 필요하다.

그렇게 하면 힙, 스택에 대해 2개의 실제 쓰이는 페이지와, 이 페이지를 할당하기 위한 페이지 디렉터리를 표현하는 페이지까지 총 3개의 페이지만 필요하게 된다.

굳이 16개의 페이지를 모두 쓸 필요가 없다.



## 20.4 역 페이지 테이블

시스템에 하나의 페이지 테이블만 둔다.

페이지 테이블은 물리페이지를 가상 주소 상의 페이지로 변환한다.



## 20.5 페이지 테이블을 디스크로 스와핑하기

모든 페이지 테이블을 메모리에 상주 시키기는 양이 너무 클 수 있다.

-> 페이지 테이블들을 커널 가상 메모리에 존재시키고, 메모리가 부족할 경우 페이지 테이블들을 디스크로 **스왑**하기도 한다.





















