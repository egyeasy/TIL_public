# 18. 페이징: 개요

첫 번째 방법 : 세그멘테이션

프로세스의 주소 공간을 가변 크기의 조각들(코드, 힙, 스택)로 분할

-> 단편화(fragmentation) 발생



두 번째 방법 : 페이징

프로세스의 주소 공간을 고정 크기의 단위로 나눔.

물리 메모리도 페이지 프레임이라고 불리는 고정 크기의 슬롯의 배열이라고 봄.



**핵심 질문: 페이지를 사용하여 어떻게 메모리를 가상화할 수 있을까**



## 18.1 간단한 예제 및 개요

장점

**유연성** - 힙과 스택이 어느 방향으로 커지는지 등에 대해 알 필요가 없다

빈 공간 관리의 **단순함** - 비어있는 n개의 페이지만 찾으면 됨



### 페이지 테이블

각 가상 페이지에 대한 물리메모리 위치를 기록

- 주소 공간의 가상 페이지 주소 변환(address translation) 정보를 저장.
- 페이지 테이블은 프로세스마다 존재함.

가상 주소 = 가상 페이지 번호(Virtaul Page Number) + 페이지 오프셋

가상 주소 공간의 크기 중에서 페이지 크기에 따라 가상 페이지 번호가 차지하는 영역이 달라진다.



VPN을 페이지 테이블의 인덱스로 사용 -> **물리 프레임 번호(PFN)**을 구할 수 있음

가상 주소 중에서 VPN 부분을 PFN으로 교체하여 물리 주소를 얻을 수 있다.(오프셋은 동일)



## 18.2 페이지 테이블은 어디에 저장되는가

페이지 테이블은 매우 커질 수 있다.

**페이지 테이블 항목**(PTE)마다 4바이트가 필요하면 4바이트 * VPN 비트 만큼 메모리가 필요하게 됨.



## 18.3 페이지 테이블에는 실제 무엇이 있는가

페이지 테이블 - 가상주소를 물리 주소로 매핑하는 데 사용되는 자료구조

여기서는 가장 간단한 형태인 **선형 페이지 테이블(linear page table)** 을 가정함.

- VPN을 index로 PFN을 얻어옴



### PTE의 구성요소

- Valid bit - 특정 변환의 유효 여부를 나타냄. 힙, 스택 등을 제외한 나머지 공간에 대해 미사용 공간임을 알리는 데 쓰임

  invalid 접근을 하면 트랩을 발생시킴

- protection bit - 페이지에 대한 R/W/E 권한

- present bit - 페이지가 물리 메모리/디스크(스왑의 경우) 중 어디에 있는지

- dirty bit - 메모리에 반입된 후 페이지가 변경되었는지
- reference bit - 페이지가 접근되었는지



## 18.4 페이징 : 너무 느림

하드웨어가 주소 변환을 담당한다고 가정.

원하는 데이터를 가져오기 위해

먼저 시스템이 가상 주소 -> 물리적 주소로 변환해야 함

이를 위해

1. 프로세스 페이지 테이블에서 적절한 PTE를 가져와서
2. 변환을 수행
3. 물리 메모리에서 데이터를 탑재

**페이지 테이블 base register** - 프로세스의 페이지 테이블의 시작 주소(물리 주소)를 저장



문제는 두 번의 메모리 접근을 함으로써 비효율이 발생한다는 것

1. 페이지 테이블에서 변환 정보 반입
2. 실제 물리 주소 접근









