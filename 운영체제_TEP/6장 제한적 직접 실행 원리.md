## 6. 제한적 직접 실행 원리

운영체제는 CPU 가상화를 통해 여러 작업들이 동시에 실행되는 것처럼 보이게 한다.

이 때 발생하는 문제는 크게 두 가지이다.

1. 성능 저하
2. 제어 문제 -> 운영체제가 제어권을 상실하면 한 프로세스가 영원히 실행을 계속하거나 컴퓨터를 장악을 우려가 있다.



### 6.1 기본 원리: 제한적 직접 실행(Limited Direct Execution)

"직접 실행" 

1. 프로세스를 실행 시작할 때 프로세스 목록에 해당 프로세스 항목을 만듦
2. 메모리 할당
3. 프로그램 코드를 디스크에서 탑재
4. 진입점(main() 루틴 등)으로 분기하여 사용자 코드를 실행

이 때 '제한'이 필요한 이유는

1. 프로그램이 운영체제가 원치 않는 일을 한다면?
2. 운영체제가 어떻게 프로그램의 실행을 중단시키고 다른 프로세스로 전환시키게 할 것인가?



### 6.2 문제점 1: 제한된 연산

사용자 모드(user mode) : 할 수 있는 일이 제한됨

커널 모드(kernel mode) : 운영체제의 중요한 코드들이 실행됨.



#### 시스템 콜

사용자 프로세스가 특권 명령어를 실행해야 한다면? -> **시스템 콜**을 사용

trap 특수 명령어를 실행해서 시스템 콜을 실행 가능 -> 커널 안으로 분기하는 동시에 특권 수준을 커널 모드로 상향 조정

trap -> 운영체제가 명령어 수행, 프로세스가 요청한 작업 처리 -> return-from-trap -> 특권 수준을 사용자 모드로 다시 하향 조정, 호출한 사용자 프로그램으로 리턴



#### 커널 스택(kernel stack)

trap 호출 시 호출한 프로세스의 중요한 레지스터들을 저장해야 함.

x86에서는 프로그램 카운터, 플래그, 몇 개의 레지스터를 각 프로세스의 **커널 스택**에 저장함.

return-from-trap 명령어가 이 값들을 스택에서 pop하여 사용자 모드 프로그램의 실행을 다시 시작함.



#### 트랩 테이블(trap table), 트랩 핸들러(trap handler)

trap이 운영체제 코드의 어디를 실행할지 어떻게 알까?(호출한 프로세서는 분기할 (운영체제의) 주소를 알 수 없게 되어 있다)

-> 커널이 부팅 시에 **트랩 테이블**을 만들고 이를 이용하여 시스템을 통제한다. 예외 사건이 일어났을 때 어떤 코드를 실행해야할지를 하드웨어에게 알려준다.

그 실행해야 하는 코드가 **트랩 핸들러**이다. 하드웨어는 이 정보를 기억하고 있다가 시스템 콜이 발생하면 해당 코드를 실행시킨다.

cf. 트랩 테이블의 위치를 알려주는 것 또한 특권 명령어다.



#### 제한적 직접 실행 프로토콜

1. 운영체제가 트랩 테이블 초기화, 하드웨어에게 트랩 핸들러 주소를 알려줌
2. 운영체제가 프로그램 탑재 및 실행 준비, return-from-trap
3. 하드웨어가 커널 스택으로부터 레지스터 복원, 사용자 모드로 이동, main으로 분기
4. 프로그램이 main 실행, 시스템 콜 호출, trap
5. 하드웨어가 레지스터를 커널 스택에 저장, 커널 모드 이동, 트랩 핸들러로 분기
6. 운영체제가 트랩을 처리, syscall의 임무 수행, return-from-trap
7. 하드웨어가 커널 스택으로부터 레지스터 복원, 사용자 모드로 이동, 트랩 이후의 PC로 분기
8. 프로그램이 main에서 리턴, trap(exit()를 통하여)
9. 운영체제가 프로세스의 메모리를 반환, 프로세스 목록에서 제거



### 6.3 문제점 2: 프로세스 간 전환

실행 중인 프로세스를 어떻게 중단시키고 다른 프로세스로 전환할 수 있을까?

운영체제가 실행하고 있지 않다면 프로세스를 중단시킬 수 없다.



### 협조 방식: 시스템 콜 기다리기

운영체제가 프로세스들이 합리적으로 행동할 것이라고 신뢰하는 방식.

프로세스가 시스템 콜을 호출하여 CPU의 제어권을 운영체제에게 넘겨주기를 기다려야 한다.

-> but 수동적인 방법



### 비협조 방식: 운영체제가 전권을 행사 - 타이머 인터럽트

타이머 장치는 수 밀리 초마다 인터럽트를 발생시키도록 프로그램됨

인터럽트 -> 수행 중인 프로세스 중단, 운영체제의 **인터럽트 핸들러** 실행 -> 운영체제는 프로세스 중단 및 다른 프로세스 실행 등의 작업



운영체제는 하드웨어에게 인터럽트가 발생했을 때 실행할 코드를 알려줌

하드웨어는, 실행 중이던 프로그램의 상태 저장 -> 나중에 return-from-trap 명령어가 프로그램을 다시 시작할 수 있도록 해야 한다.(시스템 콜 시의 동작과 유사)



### 문맥의 저장과 복원

**스케줄러(scheduler)** - 실행 중인 프로세스를 계속 실행할 것인지 아니면 다른 프로세스로 전환할 것인지를 결정

**문맥 교환(context switch)** - 현재 실행 중인 프로세스의 레지스터 값을 커널 스택에 저장. 곧 실행될 커널 스택으로부터 레지스터 값을 복원

-> return-from-trap 시 다른 프로세스로 리턴하여 실행을 다시 시작 가능

프로세스 전환을 위해 운영체제는 프로세스의 범용 레지스터, PC, 현재 커널 스택 포인터 저장 -> 실행될 프로세스의 범용 레지스터, PC 복원, 커널 스택을 해당 프로세스의 커널 스택으로 전환

**두 번의 레지스터 저장/복원** : trap시에 하드웨어가 커널 스택에 레지스터를 저장 -> 운영체제가 커널 레지스터를 해당 프로세스의 프로세스 구조체에 저장 -> 다른 프로세스로 전환

