# 7장 스케줄링: 개요

이제 프로세스를 실행시키기 위한 고수준 기법에 대해 알아보자.

고수준 정책은 스케줄링 정책에 해당하며, 원칙(discipline)이라고도 한다.



## 7.1 워크로드에 대한 가정

워크로드 - 일련의 프로세스들이 실행되는 상황

워크로드에 대한 가정들을 하고, 이 가정들을 하나씩 완화시켜가며 완화된 가정을 고려한 스케줄링 정책에 대해 알아볼 것이다.



### 워크로드(실행 중인 프로세스 혹은 작업(job))에 대한 가정

1. 모든 작업은 같은 시간 동안 실행된다.
2. 모든 작업은 동시에 도착한다.
3. 각 작업은 시작되면 완료될 때까지 실행된다.
4. 모든 작업은 CPU만 사용한다.(즉, 입출력을 수행하지 않는다)
5. 각 작업의 실행 시간은 사전에 알려져 있다.



## 7.2 스케줄링 평가 항목

스케줄링 정책의 비교를 위해 scheduling metric을 결정해야 한다.

### 반환시간(turnaround time)

반환시간 = 완료 시간 - 도착 시간



반환시간과는 다른 평가 기준으로는 공정성(fairness)가 있다.(Jain's Fairness Index)

성능과 공정성은 스케줄링에서는 서로 상충되는 목표다.



## 7.3 선입선출(FIFO)

먼저 도착한 프로세스를 먼저 처리하는 비선점 알고리즘.

다만 '1. 모든 작업 같은 시간 동안 실행'된다는 가정이 완화된다면?

먼저 도착한 프로세스의 실행시간이 길면 시스템 평균 반환 시간이 급격히 높아진다.

### convoy effect

짧은 시간 동안 자원을 사용할 프로세스들이 자원을 오랫동안 사용하는 프로세스의 종료를 기다리는 현상



## 7.4 최단 작업 우선(Shortest Job First, SJF)

가장 짧은 실행 시간을 가진 작업을 먼저 실행

모든 작업이 동시에 도착한다면, SJF가 최적(optimal)의 스케줄링 알고리즘임을 증명할 수 있다.



하지만 '2. 모든 작업이 동시에 도착'한다는 가정이 완화되어 임의에 도착한다면?

살짝 뒤늦게 도착한 작업들이 먼저 도착한 작업이 완료될 때까지 기다려야 한다.

이는 비선점(non-preemptive) 스케줄러임에 생기는 문제다.



### 선점형 스케줄러

모든 현대 스케줄러는 선점형이다. 스케줄러는 문맥 교환을 수행할 수 있고, 프로세스 중단 및 재개, 시작시킬 수 있다.



## 7.5 최소 잔여시간 우선(Shortest Time-to-Completion First, STCF)

가정 '3. 작업은 끝날 때까지 계속 실행된다'를 완화했을 때를 대비한 선점형 스케줄러.

새로운 작업이 시스템에 들어오면 남아있는 작업과 새로운 작업의 잔여 실행 시간을 계산하고 가장 적은 실행 시간을 가진 작업을 스케줄한다.

'모든 작업이 동시에 도착'하지 않는다는 가정 하에서는 최적의 스케줄러(2.의 가정에서 SJF가 최적의 스케줄링이 되는 것과 같은 맥락)





## 7.6 새로운 평가 기준 : 응답 시간

### 응답 시간(response time)

시분할 컴퓨터의 등장 -> 사용자와 시스템의 상호작용을 원활히 하기 위한 성능이 요구됨

응답시간 = 작업 처음 스케줄된 시간 - 도착 시간 = 작업이 도착할 때부터 처음 스케줄 될 때까지의 시간



앞의 스케줄링 정책들은 응답시간 측면에서 좋다고 할 수 없다.



## 7.7 라운드 로빈(Round-Robin, RR)

작업이 끝날 때까지 기다리지 않고, 일정 시간(time slice, or scheduling quantum) 동안 실행한 후 실행 큐의 다음 작업으로 전환.

RR을 타임 슬라이싱이라고 부르기도 함.



### 문맥 교환 비용

타임 슬라이스가 짧을수록 응답 시간을 기준으로한 성능은 좋아진다.

하지만 타임 슬라이스를 너무 짧게 지정하면 문맥 교환 비용이 전체 성능에 큰 영향을 미치게 된다.(비용을 상쇄(amortization)시켜야 한다)

문맥 교환에는 레지스터 저장/복원 뿐만 아니라 cpu 캐시, TLB, 분기 예측 등 다른 하드웨어에 저장된 프로그램 정보의 저장/복원이 포함된다.

따라서 적절한 타임 슬라이스를 설정할 필요가 있다.



### 공정성

RR은 공정하지만, 반환 시간과 같은 평가 기준에서는 성능이 나쁘다.

케익을 먹으면서 동시에 케익을 보관할 수는 없다.



## 7.8 입출력 연산의 고려

가정 '4. 모든 작업은 입출력을 수행하지 않는다'를 완화시켜보자.

스케줄러는 입출력 요청/완료 시에 의사 결정을 해야 한다.

한 프로세스 A의 입출력 작업이 수행되는 동안 다른 프로세스 B를 실행시킴으로써 중첩을 통해 이용률을 높일 수 있다.



## 7.9 만병 통치약은 없다

가정 '5. 스케줄러가 각 작업의 실행 시간을 알고 있다'를 완화하면?

이것에 대한 특효약은 없다.

하지만 가까운 과거를 이용하여 미래를 예측하는 스케줄러를 구현할 수는 있다 -> **멀티 레벨 피드백 큐**





























































