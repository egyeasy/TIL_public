# 17. 빈 공간 관리

빈 공간 관리는 관리 대상인 공간의 크기가

1. 고정 크기인 경우 관리가 쉬워진다 -> 고정 크기 단위의 리스트를 관리하면 된다.
2. 가변 크기인 경우가 어렵다(사용자 수준 메모리 할당 라이브러리, 세그멘테이션 사용 운영 체제에서) -> 외부 단편화가 발생.



**핵심 질문: 빈 공간을 어떻게 관리하는가**



## 17.1 가정

1. malloc(), free()와 같은 기본 인터페이스 가정

   힙의 빈공간을 관리하는 데 링크드리스트가 사용됨

2. 외부 단편화 방지에 중점을 둠

3. 클라이언트에 할당된 메모리는 다른 위치로 재배치될 수 없다고 가정(압축이 없다)



## 17.2 저수준 기법들

### 분할과 병합

**분할** - 비어있는 청크를 찾아 한 부분을 떼어내서 클라이언트(호출자)에게 반환

**병합** - 빈 공간들을 합치는 작업. 주로 청크가 반환될 때 작동함. 



### 할당된 공간의 크기 파악

free() 인터페이스는 크기를 매개변수로 받지 않는다. -> 대부분의 할당기는 추가 정보를 **header** 블럭에 저장함.

헤더 블럭은

1. 메모리에 유지되며
2. 보통 해제된 청크 바로 직전에 위치함

또한 할당된 공간의 크기, 부가적 무결성 검사를 위한 매직 넘버 및 기타 정보 저장.



### 빈 공간 리스트 내장

빈 공간 리스트는 처음에 `메모리 청크 크기 - header 크기` 만큼의 용량을 가진 항목을 갖고 있다.

그리고 이후에 N 크기의 메모리 할당 요청이 들어오면 N + header 크기 만큼의 용량을 split해서 반환한다.

할당/해제가 반복되면서 조각나있는 청크들은 어떻게 할 것인가? -> 리스트를 순회하면서 인접한 청크를 **병합**



### 힙의 확장

힙 공간이 부족할 때는?

방법 1. NULL 반환

방법 2. 운영체제에 더 많은 메모리 요청(UNIX의 sbrk 시스템 콜)



## 17.3 기본 전략

빈 공간 할당을 위한 기본 전략에 대해 알아보자

이상적인 할당기는 속도가 빠르고, 단편화를 최소화 해야한다.



### 최적 적합(Best Fit)

리스트를 전체 순회 -> 할당 가능한 청크 중에서 가장 작은 청크 반환

- 공간 낭비를 줄이기 위함
- 빈 블럭을 찾기 위해 항상 전체를 탐색해야 하는 수고로움



### 최악 적합(Worst Fit)

가장 큰 빈 청크를 찾아 그 청크의 일부만 반환

- 역시 매번 전체 탐색해야
- 단편화가 많이 발생하는 문제



### 최초 적합(First Fit)

요청보다 큰 첫 번째 블럭을 찾아서 요청만큼 반환

- 속도가 빠르다
- 리스트의 시작에 크기가 같은 객체가 많이 생길 수 있다.
- 주소 기반 정렬을 사용하기도 한다.



### 다음 적합(Next Fit)

마지막으로 찾았던 원소를 가리키는 추가의 포인터 유지

빈 공간 탐색을 리스트 전체에 더 균등하게 분산

첫 부분에만 단편이 집중적으로 발생하는 것을 방지



## 17.4 다른 접근법

### 개별 리스트

- 자주 요청하는 크기가 있다면 그 크기의 객체를 관리하는 별도의 리스트 유지

- 슬랩 할당기 -> 객체 캐시

### 버디 할당

- 이진 버디 할당기 -> 블럭이 해제될 때 비어있는 버디가 나오지 않을 때까지 위와 병합

